package "flatlang/datastruct"

import "flatlang/datastruct/list/List"
import "flatlang/datastruct/list/Iterator"
import "flatlang/datastruct/list/NoSuchElementException"
import "flatlang/operators/EqualsOperator"

[AutoFinal]
[Immutable "ImmutableHashMap"]
class HashMap<K, V> implements List<Pair<K, V>> {
    Pair<K, V>[][] buckets

    visible var Int count

    this[K key] -> V {
        get {
            return key ? getPair(key)?.value : null
        }

        set {
            if (!key) return null

            remove(key)

            getBucket(key).add(new Pair<K, V>(key, value))

            count++
        }
    }

    visible Pair<K, V>[] entries => filter({ true })

    visible HashMapIterator<K, V> iterator => new HashMapIterator(this)

    public construct(Int bucketCount = 5, private Int bucketSize = 5) {
        buckets = new Pair<K, V>[bucketCount][bucketSize]
    }

    public construct(HashMap<K, V> source, Int bucketCount = 5, private Int bucketSize = 5) {
        this(bucketCount, bucketSize)

        source.forEach(pair => {
            add(pair.key, pair.value)
        })
    }

    public add(K key, V value) => this[key] = value
    public add(Pair<K, V> pair) => this[pair.key] = pair.value
    public addAll(List<Pair<K, V>> pairs) => pairs.forEach({ add(_) })
    public addAll(HashMap<K, V> map) => map.entries.forEach({ add(_) })

    public getOrDefault(K key, defaultValue() -> V) -> V => containsKey(key) ? this[key] : add(key, defaultValue())

    [Override]
    public toArray() => map({ _ })

    // [Override]
    // public contains(Pair<K, V> value) =>
    //     (let pair = getPair(value.key)) &&
    //     pair.value == value.value

    [Override]
    public contains(Pair<K, V> value) -> Bool {
        if (!value.key) return false

        let pair = getPair(value.key)

        return pair && pair.value == value.value
    }

    [Override]
    public any(func(Pair<K, V>) -> Bool) => false {
        for (bucket in buckets) {
            for (pair in bucket) {
                if (pair && func(pair)) {
                    return true
                }
            }
        }
    }

    [Override]
    public all(func(Pair<K, V>) -> Bool, Bool stopOnContradiction = true) -> Bool {
        var contradiction = false

        for (bucket in buckets) {
            for (pair in bucket) {
                if (pair && !func(pair)) {
                    if (stopOnContradiction) {
                        return false
                    }

                    contradiction = true
                }
            }
        }

        return !contradiction
    }

    [Override]
    public map<Out>(func(Pair<K, V>, Int, HashMap<K, V>) -> Out) -> Out[] {
        let array = new Out[]

        var Int i = 0

        for (bucket in buckets) {
            for (pair in bucket) {
                if (pair) {
                    array.add(func(pair, i++, this))
                }
            }
        }

        return array
    }

    [Override]
    public filter(func(Pair<K, V>, Int, HashMap<K, V>) -> Bool) -> Pair<K, V>[] {
        let array = new Pair<K, V>[]

        var Int i = 0

        for (bucket in buckets) {
            for (pair in bucket) {
                if (pair && func(pair, i++, this)) {
                    array.add(pair)
                }
            }
        }

        return array
    }

    [Override]
    public join(String delimiter) -> String {
        var Int i = 0

        var output = ""

        for (bucket in buckets) {
            for (pair in bucket) {
                if (pair) {
                    if (i > 0) {
                        output = output + delimiter
                    }

                    output = output + pair
                }
            }
        }

        return output
    }

    [Override] public skip(Int num) => map({ _ }).skip(num)
    [Override] public take(Int num) => map({ _ }).take(num)
    [Override] public reverse() => map({ _ }).reverse()

    [Override]
    public firstWhere(func(Pair<K, V>) -> Bool) -> Pair<K, V> => null//=>
    //buckets.firstNonNull({ _.firstWhere(pair -> pair && func(pair)) })
    {
        for (bucket in buckets) {
            for (pair in bucket) {
                if (pair && func(pair)) {
                    return pair
                }
            }
        }
    }

    [Override]
    public forEach(func(Pair<K, V>, Int, HashMap<K, V>)) => this {
        var Int i = 0

        for (bucket in buckets) {
            for (pair in bucket) {
                if (pair) {
                    func(pair, i++, this)
                }
            }
        }
    }

    getBucket(K key) => buckets[(Int)(key.hashCodeLong & (buckets.count - 1))]
    getPair(K key) => getBucket(key).filter(x => x && x.key.equals(key)).first

    public remove(K key) -> V => null {
        if (!key) return null

        let bucket = getBucket(key)

        var Int i = 0

        for (pair in bucket) {
            if (pair && pair.key.equals(key)) {
                bucket.remove(i)
                count--

                return pair.value
            } else {
                i++
            }
        }
    }

    public containsKey(K key) => key && getPair(key)

    public clone() => new HashMap<K, V>(this)

    public toImmutable() => new ImmutableHashMap<K, V>(this)

    public toString() => this.class.location + " {" + map(p => { p.key + ": " + p.value }).join(", ") + "}"

    [AutoFinal]
    class HashMapIterator<K, V> implements Iterator<Pair<K, V>> {
        visible var Int position

        var Iterator<Array<Pair<K, V>>> bucketIterator
        var Iterator<Pair<K, V>> valueIterator

        visible Bool hasNext => position < map.count && (bucketIterator.hasNext || valueIterator?.hasNext)
        visible Bool hasPrevious => bucketIterator.hasPrevious || valueIterator?.hasPrevious

        visible Pair<K, V> stepNext {
            get {
                if (valueIterator?.hasNext) {
                    position++
                    return valueIterator.stepNext
                } else if (bucketIterator.hasNext) {
                    position++
                    valueIterator = bucketIterator.stepNext.iterator
                    return valueIterator.stepNext
                }

                throw new NoSuchElementException()
            }

            no set
        }

        visible Pair<K, V> current => valueIterator?.current
        visible Pair<K, V> previous {
            get {
                if (valueIterator?.hasPrevious) {
                    return valueIterator.previous
                } else if (bucketIterator.hasPrevious) {
                    return bucketIterator.previous.last
                }
            }
        }
        visible Pair<K, V> next {
            get {
                if (valueIterator?.hasNext) {
                    return valueIterator.next
                } else if (bucketIterator.hasNext) {
                    return bucketIterator.next.first
                }
            }
        }

        public construct(visible HashMap<K, V> map) {
            reset()
        }

        public reset() => this {
            position = 0
            bucketIterator = map.buckets.iterator
            valueIterator = bucketIterator.hasNext ? bucketIterator.stepNext.iterator : null
        }
    }
}